---
description: React Best Practices for Code Reviews
alwaysApply: false
---

## Memoization Patterns

### ✅ REQUIRED: Memoize Expensive Computations
- **ALWAYS** use `useMemo` for expensive computations, object/array creations, and filtered data
- **ALWAYS** use `useCallback` for event handlers and functions passed as props

### Examples of Required Memoization:

```typescript
// ✅ GOOD - Memoized expensive computation
const filteredAssets = useMemo(() => 
  assets.filter(asset => asset.chainId === selectedChainId), 
  [assets, selectedChainId]
)

// ✅ GOOD - Memoized event handler
const handleAssetChange = useCallback((assetId: AssetId) => {
  setSelectedAsset(assetId)
}, [])
```

### ❌ BAD - Missing Memoization:
```typescript
// ❌ BAD - Expensive computation not memoized
const filteredAssets = assets.filter(asset => asset.chainId === selectedChainId)

// ❌ BAD - Event handler not memoized
const handleAssetChange = (assetId: AssetId) => {
  setSelectedAsset(assetId)
}
```

## Hook Dependencies

### ✅ REQUIRED: Proper Hook Dependencies
- **ALWAYS** include all dependencies in `useEffect`, `useMemo`, `useCallback` dependency arrays
- **NEVER** use `// eslint-disable-next-line react-hooks/exhaustive-deps` unless absolutely necessary
- **ALWAYS** explain why dependencies are excluded if using eslint disable

### Examples:
```typescript
// ✅ GOOD - All dependencies included
useEffect(() => {
  fetchData(userId, selectedAsset)
}, [userId, selectedAsset])

// ✅ GOOD - Properly memoized callback with dependencies
const handleSubmit = useCallback((data: FormData) => {
  submitForm(data, userId)
}, [userId])

// ✅ GOOD - Memoized value with all dependencies
const processedData = useMemo(() => 
  processData(rawData, filters), 
  [rawData, filters]
)
```

## Component Structure

### ✅ REQUIRED: Named Exports Only
- **ALWAYS** use named exports for components
- **NEVER** use default exports for components

```typescript
// ✅ GOOD - Named export
export const MyComponent = () => {
  return <div>Content</div>
}

// ❌ BAD - Default export
export default MyComponent = () => {
  return <div>Content</div>
}
```

### ✅ REQUIRED: Small Component Files
- **KEEP** component files under 150 lines when possible
- **BREAK DOWN** large components into smaller, reusable pieces
- **EXTRACT** complex logic into custom hooks

## Component Splitting

### ✅ REQUIRED: Split Large Components
- **ALWAYS** split components that are over 100 lines
- **ALWAYS** extract reusable UI pieces into separate components
- **ALWAYS** split complex JSX in `useMemo` into separate components
- **ALWAYS** extract form sections, list items, and modal content into separate components
- **KEEP** small, simple components in the same file only if they're under 20 lines and specific to the parent

### Examples:
```typescript
// ✅ GOOD - Split large component
// TradeForm.tsx
export const TradeForm = () => {
  const [tradeInput, setTradeInput] = useState<TradeInput>()
  
  return (
    <form>
      <AssetSelector 
        selectedAsset={tradeInput?.sellAsset}
        onSelect={setSellAsset}
      />
      <AmountInput 
        value={tradeInput?.amount}
        onChange={setAmount}
      />
      <TradeSummary tradeInput={tradeInput} />
      <TradeActions onExecute={handleExecute} />
    </form>
  )
}

// ✅ GOOD - Extracted components in separate files
// components/AssetSelector/AssetSelector.tsx
export const AssetSelector = ({ selectedAsset, onSelect }: AssetSelectorProps) => {
  // Implementation
}

// ✅ GOOD - Small component in same file (under 20 lines)
export const TradeForm = () => {
  const [isLoading, setIsLoading] = useState(false)
  
  const LoadingSpinner = () => (
    <div className="loading">
      <Spinner />
      <span>Processing...</span>
    </div>
  )
  
  return (
    <div>
      {/* form content */}
      {isLoading && <LoadingSpinner />}
    </div>
  )
}
```

### ❌ BAD - Large, Monolithic Components:
```typescript
// ❌ BAD - Too much JSX in useMemo
const TradeForm = () => {
  const complexJSX = useMemo(() => (
    <div>
      <div className="asset-selector">
        <label>Select Asset</label>
        <select>
          {assets.map(asset => (
            <option key={asset.id} value={asset.id}>
              {asset.name} ({asset.symbol})
            </option>
          ))}
        </select>
      </div>
      <div className="amount-input">
        <label>Amount</label>
        <input type="number" />
      </div>
      <div className="trade-summary">
        <h3>Trade Summary</h3>
        <div className="summary-item">
          <span>You pay:</span>
          <span>{sellAmount} {sellAsset.symbol}</span>
        </div>
        <div className="summary-item">
          <span>You receive:</span>
          <span>{buyAmount} {buyAsset.symbol}</span>
        </div>
        <div className="summary-item">
          <span>Fee:</span>
          <span>{fee} {sellAsset.symbol}</span>
        </div>
      </div>
      <div className="trade-actions">
        <button onClick={handleExecute}>Execute Trade</button>
        <button onClick={handleCancel}>Cancel</button>
      </div>
    </div>
  ), [assets, sellAmount, buyAmount, fee, sellAsset, buyAsset])

  return <form>{complexJSX}</form>
}

// ❌ BAD - Large component with everything in one file
export const TradeForm = () => {
  // 200+ lines of component logic
  // Multiple complex JSX sections
  // Multiple state management
  // Multiple event handlers
  // All in one component
}
```

### ✅ REQUIRED: Extract Complex JSX from useMemo
- **ALWAYS** extract complex JSX from `useMemo` into separate components
- **ALWAYS** use `React.memo` for extracted components to maintain performance
- **ALWAYS** pass only necessary props to extracted components

```typescript
// ✅ GOOD - Extracted complex JSX
const TradeForm = () => {
  const tradeSummary = useMemo(() => (
    <TradeSummary 
      sellAmount={sellAmount}
      buyAmount={buyAmount}
      sellAsset={sellAsset}
      buyAsset={buyAsset}
      fee={fee}
    />
  ), [sellAmount, buyAmount, sellAsset, buyAsset, fee])

  return (
    <form>
      <AssetSelector />
      <AmountInput />
      {tradeSummary}
      <TradeActions />
    </form>
  )
}

// ✅ GOOD - Memoized extracted component
const TradeSummary = memo<TradeSummaryProps>(({ 
  sellAmount, 
  buyAmount, 
  sellAsset, 
  buyAsset, 
  fee 
}) => (
  <div className="trade-summary">
    <h3>Trade Summary</h3>
    <SummaryItem label="You pay:" value={`${sellAmount} ${sellAsset.symbol}`} />
    <SummaryItem label="You receive:" value={`${buyAmount} ${buyAsset.symbol}`} />
    <SummaryItem label="Fee:" value={`${fee} ${sellAsset.symbol}`} />
  </div>
))
```

## State Management

### ✅ REQUIRED: Proper State Lifting
- **USE** local state for component-level state
- **LIFT** state up when needed across multiple components
- **USE** Context for avoiding prop drilling
- **USE** Redux only for global state shared across multiple places

### Examples:
```typescript
// ✅ GOOD - Local state for component-specific data
const [isOpen, setIsOpen] = useState(false)

// ✅ GOOD - Context for avoiding prop drilling
const ModalContext = createContext<ModalContextType>()

// ✅ GOOD - Redux for global state
const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    setUser: (state, action) => {
      state.user = action.payload
    }
  }
})
```

## Error Handling

### ✅ REQUIRED: Proper Error Boundaries
- **ALWAYS** wrap components in error boundaries for production
- **ALWAYS** handle async errors properly
- **ALWAYS** provide user-friendly error messages

```typescript
// ✅ GOOD - Error boundary usage
<ErrorBoundary FallbackComponent={ErrorPage}>
  <App />
</ErrorBoundary>

// ✅ GOOD - Async error handling
const handleAsyncOperation = useCallback(async () => {
  try {
    const result = await apiCall()
    setData(result)
  } catch (error) {
    showErrorToast(error)
  }
}, [])
```

## Performance Patterns

### ✅ REQUIRED: Virtualization for Large Lists
- **ALWAYS** use virtualization for lists with 100+ items
- **ALWAYS** implement proper key props for list items

```typescript
// ✅ GOOD - Virtualized list
import { FixedSizeList } from 'react-window'

const VirtualizedList = ({ items }) => (
  <FixedSizeList
    height={400}
    itemCount={items.length}
    itemSize={50}
  >
    {({ index, style }) => (
      <div style={style}>
        {items[index]}
      </div>
    )}
  </FixedSizeList>
)
```

### ✅ REQUIRED: Lazy Loading
- **ALWAYS** lazy load heavy components
- **ALWAYS** use React.lazy for code splitting

```typescript
// ✅ GOOD - Lazy loading
const HeavyComponent = lazy(() => import('./HeavyComponent'))

// ✅ GOOD - Suspense wrapper
<Suspense fallback={<Skeleton />}>
  <HeavyComponent />
</Suspense>
```

## TypeScript Best Practices

### ✅ REQUIRED: Proper TypeScript Usage
- **ALWAYS** use explicit types for function parameters and return values
- **ALWAYS** use interfaces for object shapes
- **ALWAYS** use enums for constants
- **NEVER** use `any` type unless absolutely necessary

```typescript
// ✅ GOOD - Explicit types
interface AssetListProps {
  assets: Asset[]
  onSelect: (asset: Asset) => void
  isLoading?: boolean
}

const AssetList: React.FC<AssetListProps> = ({ assets, onSelect, isLoading }) => {
  // implementation
}

// ✅ GOOD - Enum usage
enum SortDirection {
  Asc = 'asc',
  Desc = 'desc'
}
```

## ✅ Code Review Checklist

When reviewing React code, ensure:

1. All expensive computations are memoized with `useMemo`
2. All event handlers are memoized with `useCallback`
3. Components receiving props are wrapped with `memo`
4. All hook dependencies are properly included
5. Components use named exports only
6. Files are under 200 lines when possible
7. Large components (>100 lines) are split into smaller components
8. Complex JSX in `useMemo` is extracted into separate components
9. Reusable UI pieces are extracted into separate components
10. Small components (<20 lines) can stay in same file if specific to parent
11. Error boundaries are in place
12. Async operations have proper error handling
13. Large lists use virtualization
14. Heavy components are lazy loaded
15. TypeScript types are explicit and proper

## ❌ Common Anti-Patterns to Flag

- Missing `useMemo` for expensive computations
- Missing `useCallback` for event handlers
- Missing `memo` for components with props
- Incomplete dependency arrays in hooks
- Default exports for components
- Large component files (>150 lines)
- Large monolithic components (>100 lines) not split
- Complex JSX in `useMemo` not extracted
- Reusable UI pieces not extracted into separate components
- Missing error boundaries
- Unhandled async errors
- Large lists without virtualization
- Heavy components without lazy loading
- Use of `any` type
- Missing TypeScript types
